// Copyright 2019-2022 Jeroen Simonetti
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package routesync

import (
	"context"
	"errors"
	"fmt"
	"net"
	"sync"
	"time"

	"github.com/jsimonetti/hodos/internal/log"
	"github.com/jsimonetti/rtnetlink"
	"github.com/mdlayher/netlink"
	"golang.org/x/sys/unix"
)

// Sync will synchronise all (useful) routes that use a specific
// outbound interface into a new routing table.
// It will also setup an routing rule to use this table
// for traffic from this interface (ip) to any of the destinations
// reachable through it.
type Sync struct {
	ifi       string
	interFace *net.Interface
	table     uint32
	ctx       context.Context
	ctxCancel context.CancelFunc

	downFunc func()
	upFunc   func()
	l        log.Logger
	wg       *sync.WaitGroup

	myPid  uint32
	nlconn *rtnetlink.Conn
	metric uint32
}

// New will return an initialised route sync object
// Use *Sync.Run() to start it and *Sync.Wait() to block
// until it has finished cleanup
func New(ctx context.Context, ifi string, table uint32, opts ...Option) (*Sync, error) {

	m := &Sync{
		ifi:   ifi,
		table: table,

		downFunc: func() {},
		upFunc:   func() {},
		l:        log.Default(),
		wg:       &sync.WaitGroup{},
	}
	m.ctx, m.ctxCancel = context.WithCancel(ctx)

	for _, option := range opts {
		if err := option(m); err != nil {
			return nil, err
		}
	}

	if m.nlconn == nil {
		return nil, errors.New("empty rtnetlink conn")
	}
	return m, nil
}

type Option func(m *Sync) error

// Logger is a functional Option to set
// a new logger for this monitor
func Logger(l log.Logger) Option {
	return func(m *Sync) error {
		m.l = l
		return nil
	}
}

// WithRTConn is a functional Option to set
// the PID rtnetlink conn
func WithRTConn(c *rtnetlink.Conn) Option {
	return func(m *Sync) error {
		m.nlconn = c
		return nil
	}
}

// WithPid is a functional Option to set
// the pid for this monitor
func WithPid(pid uint32) Option {
	return func(m *Sync) error {
		m.myPid = pid
		return nil
	}
}

// WithMetric is a functional Option to set
// the metric for this monitor
func WithMetric(metric uint32) Option {
	return func(m *Sync) error {
		m.metric = metric
		return nil
	}
}

// Wait will wait for this run to finish before returning
func (s *Sync) Wait() {
	s.wg.Wait()
}

func (s *Sync) Run() error {
	// We use a waitgroup to allow cleanup to happen before
	// we are closed
	s.wg.Add(1)
	defer s.wg.Done()
	s.l.Debugf("starting routeSync for %q table %d", s.interFace, s.table)

	nl, err := rtnetlink.Dial(&netlink.Config{Groups: 0x4000440}) // TODO(jsi): why this group mask?
	if err != nil {
		return fmt.Errorf("RouteMonitor: could not dial rtnetlink: %w", err)
	}
	defer nl.Close()

	ifIndex := uint32(0)
	for {
		select {
		case <-s.ctx.Done():
			// our caller has closed the context
			// so we stop monitoring
			return s.cleanup()
		default:
			s.interFace, err = net.InterfaceByName(s.ifi)
			if err == nil {
				ifIndex = uint32(s.interFace.Index)
				goto NEXT
			}
			// wait for interface to become available
			time.Sleep(5 * time.Second)
		}
	}
NEXT:
	// bootstrap our state by getting all routes for the interface
	rreq := &rtnetlink.RouteMessage{
		Attributes: rtnetlink.RouteAttributes{
			OutIface: ifIndex,
		},
	}
	// TODO(jsi): why is this returning routes for other interfaces??
	nl.Send(rreq, unix.RTM_GETROUTE, netlink.Request|netlink.Dump)

	// Loop until we get closed by our parent context
	for {
		// To prevent blocking indefinately, we use a read
		// deadline on the netlink socket
		nl.SetReadDeadline(time.Now().Add(1 * time.Second))
		select {
		case <-s.ctx.Done():
			// our caller has closed the context
			// so we stop monitoring
			return s.cleanup()
		default:
			msgs, omsgs, err := nl.Receive()
			if err != nil {
				if e, ok := err.(net.Error); ok && e.Timeout() {
					// timeouts are fine, it just means we hit our deadline
					// and can unblock
					continue
				}
				s.l.Printf("RouteMonitor receive error: %s", err)
			}

			for i, msg := range msgs {
				// we ignore netlink events generated by ourselves
				if omsgs[i].Header.PID == s.myPid {
					continue
				}

				if m, ok := msg.(*rtnetlink.RouteMessage); ok {
					// We are not interested in events that do not concern our
					// interface or are happening in routing tables
					// other then RT_TABLE_LOCAL (255) or RT_TABLE_MAIN (254)
					if m.Attributes.OutIface != ifIndex ||
						(m.Attributes.Table != unix.RT_TABLE_LOCAL &&
							m.Attributes.Table != unix.RT_TABLE_MAIN) {
						//m.Attributes.Table != s.table) {
						continue
					}
					// If this is a new route, we trigger our
					// internal up action
					if omsgs[i].Header.Type == unix.RTM_NEWROUTE {
						if err := s.routeUpAction(m); err != nil {
							s.l.Debugf("routeUpAction: failed to add route to table '%d', '%+v': %s", s.table, m, err)
						}

						continue
					}
					// If this is a deleted route, we trigger our
					// internal down action
					if omsgs[i].Header.Type == unix.RTM_DELROUTE {
						if err := s.routeDownAction(m); err != nil {
							s.l.Debugf("routeDownAction: failed to remove route from table '%d', '%+v': %s", s.table, m, err)
						}
						continue
					}
				}
			}
		}
	}
}

func (s *Sync) Stop() {
	s.l.Debugf("stopping routeSync for %q table %d", s.ifi, s.table)
	s.ctxCancel()
	s.wg.Wait()
}

// Cleanup will clean our state
// This will do two things:
// 1. completely remove all routing rules that use our table
// 2. remote all routes from our table
// unfortunately it is not possible to actually delete the
// routing table entirely, so that remains
// TODO(jsi): find a way to delete the table aswel
func (s *Sync) cleanup() error {
	if s.table == 0 {
		return nil
	}
	// remove routing and rules
	nl, err := rtnetlink.Dial(nil)
	if err != nil {
		s.l.Printf("routeCleanup: could not dial rtnetlink: %s", err)
		return err
	}
	defer nl.Close()

	// first get all rules for this table
	// benefit of this, it works for all address families
	rumsgs, _ := nl.Rule.List()
	for _, msg := range rumsgs {
		if *msg.Attributes.Table == s.table {
			if err = nl.Rule.Delete(&msg); err != nil {
				s.l.Printf("routeCleanup: error deleting route from table %d: %s", s.table, err)
			}
		}
	}
	// get all routes in table and remove then
	rtmsgs, _ := nl.Route.List()
	for _, msg := range rtmsgs {
		if msg.Attributes.Table == s.table {
			msg.Flags = 0 // don't use flags
			if err = nl.Route.Delete(&msg); err != nil {
				s.l.Printf("routeCleanup: error deleting route from table %d: %s", s.table, err)
			}
			if msg.Attributes.Gateway != nil {
				msg.Table = unix.RT_TABLE_MAIN
				msg.Attributes.Table = unix.RT_TABLE_MAIN

				// restore the original route back to the main table
				if err := s.nlconn.Route.Add(&msg); err != nil {
					s.l.Printf("routeCleanup: error restoring route from table %d: %s", s.table, err)
				}

				// remove any failed/non-failed route from main table
				msg.Attributes.Priority = s.metric
				if err := s.nlconn.Route.Delete(&msg); err != nil {
					s.l.Printf("could not delete route with ifi metric: %+v: %s", msg, err)
				}
			}
		}
	}
	return nil
}

var maxMetric uint32 = 65534 // uint16 max size -1 so we never overflow

// routeUpAction will do two things:
//  1. if this is a route from the RT_TABLE_LOCAL(255) table and
//     has scope RT_SCOPE_HOST, this is a local ip adres and we
//     add a route rule to use our table for any traffic from this IP.
//  2. if this is not a broadcast or local route, we add this route
//     to our table.
func (s *Sync) routeUpAction(m *rtnetlink.RouteMessage) error {
	s.l.Debugf("routeUpAction: %q received '%#v'\n", s.interFace.Name, m)
	if m == nil {
		return nil
	}

	// we add routes into the table here
	// we filter out some route types that are not useful here
	if m.Type != unix.RTN_BROADCAST &&
		m.Type != unix.RTN_LOCAL {
		m.Flags = 0 // don't set flags
		if m.Attributes.Gateway != nil {
			//if m.Flags == unix.RTNH_F_LINKDOWN { // link is down, so we must use the fail metric
			//	newmetric = maxMetric + s.metric
			//}
			if err := ChangeMetric(s.nlconn, *m, s.metric); err != nil {
				// this error can be expected at initial startup
				// since the interface will already have routes
				s.l.Printf("routeUpAction: change error: %s", err)
			}
		}
		m.Table = uint8(s.table)
		m.Attributes.Table = s.table
		return s.nlconn.Route.Add(m)
	}
	return nil
}

// routeDownAction will do two things:
//  1. if this is a route from the RT_TABLE_LOCAL(255) table and
//     has scope RT_SCOPE_HOST, this is a local ip adres and we
//     remove the corresponding route rule.
//  2. remove this route from the routing table.
func (s *Sync) routeDownAction(m *rtnetlink.RouteMessage) error {
	s.l.Debugf("routeDownAction: %q received '%#v'\n", s.interFace.Name, m)
	if m == nil {
		return nil
	}

	// we remove the route from the table here
	m.Flags = 0 // don't set flags
	m.Table = uint8(s.table)
	m.Attributes.Table = s.table
	return s.nlconn.Route.Delete(m)
}
